# Unix Flashcards based on Exam 18/19

## What is the difference between function calls and system calls.

A function call is a call to a function in the same program.
A system call is a call to a function in the operating system.

## Describe the structure of a processâ€™s address space

The address space of a process is divided into 5 segments:

1. Text segment: contains the executable code of the program.
2. Initialized data segment: contains the initialized global and static variables.
3. Uninitialized data segment: contains the uninitialized global and static variables.
4. Stack segment: contains the local variables and the return addresses of the function calls.
5. Heap segment: contains the dynamically allocated memory.

## Describe the linking phase of the compilation process.

The linking phase of the compilation process is the phase where the linker combines the object files generated by the compiler into a single executable file.

## Why do we need libraries?

We need libraries because they contain functions that are used by multiple programs.
Instead of having to write the same function multiple times, we can just call the function from the library.

## What is a static library?

A static library is a library that is linked to the executable at compile time.
The functions in the static library are copied into the executable.


## What is a dynamic library?

A dynamic library is a library that is linked to the executable at run time.
The functions in the dynamic library are not copied into the executable.

## What is the difference between a static library and a dynamic library?

A static library is linked to the executable at compile time.
A dynamic library is linked to the executable at run time.

## what is the advantage of using dynamic libraries?

The advantage of using dynamic libraries is that the executable file is smaller.

## What are the steps of the compilation process?

1. Preprocessing: \
   - The preprocessor touches everything that starts with a #.
   - It replaces the #include statements with the contents of the included file.
   - It replaces the #define statements with the defined values.
   - It replaces the #ifdef statements with the code inside the #ifdef and #endif statements if the condition is true.

2. Compilation \
   - The compiler converts the source code into assembly code.
   - The compiler converts the assembly code into object code.
   - The compiler generates the object file.

3. Linking \
    - The linker combines the object files generated by the compiler into a single executable file.
    - The linker resolves the external references.
    - The linker generates the executable file.

## Wow are static libraries created

Static libraries are created by the ar command.
You preprocess the source code, compile the source code, and then use the ar command to create the static library.

## Give an example of the creation and usage of a static library in code

The following code creates a static library called libmylib.a and uses it in the program main.c:

```bash
gcc -c mylib.c
ar rcs libmylib.a mylib.o
gcc -o main main.c -L. -lmylib
```

where

- gcc -c mylib.c: compiles mylib.c into mylib.o
- ar -rcs libmylib.a mylib.o: creates the static library libmylib.a from mylib.o
  - -r option replaces the object file in the library if it already exists
  - -c creates the library if it does not exist
  - -s creates an index in the library 
- gcc -o main main.c -L. -lmylib: links the static library libmylib.a to the executable main

## Name the main Unix mechanisms supporting parallelism

- Processes
  - new processes are created with the fork system call or the clone system call 
- Threads
  - new threads are created with the pthread_create system call

In order to make shure that the processes and threads do not interfere with each other, we need to use synchronization mechanisms such as mutexes, semaphores, and condition variables.

## What are processes?

A process is an instance of a program in execution.
A process has its own address space, its own stack, and its own heap.
A process can have multiple threads.

## What are threads?

A thread is a sequence of instructions that can be executed independently of other code.
A thread has its own stack, but it shares the address space and the heap with other threads in the same process.

## How do processes enable parallelism?

Processes enable parallelism by allowing multiple processes to run at the same time.
Because each process has its own address space, its own stack, and its own heap, multiple processes can run at the same time without interfering with each other.

## How do threads enable parallelism?

Threads enable parallelism by allowing a single process to handle multiple tasks at the concurrently.
Because threads share the address space and the heap, they can access the same data at the same time.

## What is the difference between a process and a thread?

A process has its own address space, its own stack, and its own heap.
A thread has its own stack, but it shares the address space and the heap with other threads in the same process.

## What is the code to create a process and explain the code

The code to create a process is:

```c
pid_t pid = fork();
```

The fork system call creates a new process.
The fork system call returns the process id of the child process to the parent process and returns 0 to the child process.

Using a switch statement we can make the parent process do one thing and the child process do another thing.

## What is the code to create a thread and explain the code

The code to create a thread is:

```c
pthread_t tid;
pthread_create(&tid, NULL, thread_function, NULL);
```

The pthread_create system call creates a new thread.
The pthread_create system call returns 0 if the thread was created successfully.

&tid is the address of the thread id variable.
thread_function is the function that the thread will execute.
The last argument is the argument that will be passed to the thread function.

## What is a signal?

A signal is a notification sent to a process or a thread to notify it of an event.
It works by interrupting the process or the thread and executing a signal handler.

## What is a signal handler?

A signal handler is a function that is executed when a signal is received.
The signal handler is executed instead of the code that was executing when the signal was received.

## Why do we need signals?

We need signals to notify a process or a thread of an event so it can take action.

## Write some code to handle a signal

The following code handles the SIGINT signal:

```c
#include <stdio.h>
#include <signal.h>

void signal_handler(int signal)
{
    printf("REEE");
    fflush(stdout);   
}


int main()
{
    signal(SIGINT, signal_handler);

    while (1){
        printf("LaLaLaLa\n");   
    }
    return 0;
}
```

## How is a signal sent to a process?

A signal can be raised by the kill system call and providing the process id of the process that should receive the signal.

```c
kill(pid, signal);
```

## How is a signal sent to a thread?

A signal can be sent to a thread by using the pthread_kill system call and providing the thread id of the thread that should receive the signal.

```c
pthread_kill(tid, signal);
```

## Explain in detail how two processes communicate using SOCK_STREAM (Server)?

Two processes communicate using SOCK_STREAM by creating a socket, binding the socket to an address, listening for connections, accepting connections, and sending and receiving data.

``` c
// creating an empty file descriptor for the socket
int listenfd = 0;

// creating empty sockaddr_in object
struct sockaddr_in serv_addr;


// creating the file descriptor for the socket
listenfd = socket(AF_INET, SOCK_STREAM, 0);

// allocating memory for the socket address 
memset(&serv_addr, '0', sizeof(serv_addr)); 

// filling in the data for the socket address    
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
serv_addr.sin_port = htons(5000);

// binding the socket to the address
bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

// listening for connections
listen(listenfd, 10);

while (1){
   connfd = accept(listenfd, NULL, NULL);

    // sending data
    write(connfd, "HI \n", strlen("HI \n"));
}

```

## Explain in detail how two processes communicate using SOCK_STREAM (Clinet)?

Two processes communicate using SOCK_STREAM by creating a socket, connecting to a server, and sending and receiving data.

``` c

// creating an empty file descriptor for the socket
int sockfd = 0;

// creating empty sockaddr_in object
struct sockaddr_in serv_addr;

// creating the file descriptor for the socket
sockfd = socket(AF_INET, SOCK_STREAM, 0);

// allocating memory for the socket address
memset(&serv_addr, '0', sizeof(serv_addr));

// filling in the data for the socket address
serv_addr.sin_family = AF_INET;
serv_addr.sin_port = htons(5000);

// connecting to the server
connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

// receiving data
read(sockfd, recvBuff, sizeof(recvBuff) - 1);

```

## What is the internt family of for ip4 and ip6?

The internet family for ip4 is AF_INET.
The internet family for ip6 is AF_INET6.

## Give the code to create a socket and explain it

The code to create a socket is:

```c
int socketfd = socket(AF_INET, SOCK_STREAM, 0);
```

The socket system call creates a socket.

- AF_INET specifies the internet family for ip4
- SOCK_STREAM specifies that the socket is a stream socket
- Alternatively, SOCK_DGRAM specifies that the socket is a datagram socket
- 0 specifies the protocol to use, which is 0 for TCP and UDP
- The socket system call returns the file descriptor for the socket

## Give the code to create a socket address and explain it

The code to create a socket address is:

```c
struct sockaddr_in serv_addr;

memset(&serv_addr, '0', sizeof(serv_addr));

serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
serv_addr.sin_port = htons(5000);

```

1. We create and empty sockaddr_in object
2. We fill the memory of the sockaddr_in object with 0 characters
3. We specify the internet family for ip4
4. We specify the ip address of the socket
5. We specify the port of the socket

## Give the code to bind a socket to an address and explain it

The code to bind a socket to an address is:

```c
bind(listenfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
```

The bind system call binds a socket to an address.

- listenfd is the file descriptor of the socket
- serv_addr is the address of the socket, we need to cast it to a sockaddr pointer
- sizeof(serv_addr) is the size of the address
- The bind system call returns 0 if the socket was bound successfully
- after the socket is bound to an address, it can be used to send and receive data

## Give the code to listen for connections and explain it

The code to listen for connections is:

```c
listen(listenfd, 10);
```

The listen system call listens for connections on a socket. \
The listen system call returns 0 if the socket is listening for connections.

- listenfd is the file descriptor of the socket
- 10 is the maximum number of connections that can be queued for the socket

after this is called the socket is ready to accept connections and has a queue of possible connections

## Give the code to accept a connection on the server side and explain it

The code to accept a connection is:

```c

connfd = accept(listenfd, NULL, NULL);

```

The accept system call accepts a connection on a socket.

- it returns the file descriptor of the connection
- the first argument is the file descriptor of the socket
- the second argument is a pointer to a sockaddr object that will be filled with the address of the client
- the third argument is a pointer to an integer that will be filled with the size of the address of the client

## Give the code to connect to a server wit  a socket and explain it

The code to connect to a server is:

```c

connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

```

The connect system call connects a socket to a server.

- it returns 0 if the socket was connected successfully
- the first argument is the file descriptor of the socket
- the second argument is a pointer to a sockaddr object that contains the address of the server
- the third argument is the size of the address of the server
- after this is called the socket is ready to send and receive data

## Give the code to send data and explain it

The code to send data is:

```c
write(connfd, "HI \n", strlen("HI \n"));
```

The write system call writes data to a file descriptor.

- connfd is the file descriptor of the connection
- "HI \n" is the data to send
- strlen("HI \n") is the length of the data to send
- returns the number of bytes written or -1 if an error occured

## What are the key code snippets of a socket server?

1. Creating the serv_addr object, allocating memory for it, and filling it with data
2. Creating the socket and filling it with sock()
3. Binding the socket to the address with bind()
4. Listening for connections with listen()
5. Accepting connections with accept()
6. Sending and receiving data with read() and write()

## What are the key code snippets of a socket client?

1. Creating the serv_addr object, allocating memory for it, and filling it with data
2. Creating the socket and filling it with sock()
3. Connecting to the server with connect()
4. Sending and receiving data with read() and write()
